#pragma once
#include <string>
#include <iostream>
using namespace std;
namespace ext
{
	
	enum Month
	{
		January = 1,
		February,
		March,
		April,
		May,
		June,
		July,
		August,
		September,
		October,
		Novemver,
		December
	};

	enum DateFormat
	{
		MonthAsInt,
		MonthAsString
	};

	enum Season
	{
		Winter,
		Spring,
		Summer,
		Autumn
	};

	struct Date
	{
		int year;
		Month month;
		int day;
	};

	/*
	Возвращает Юлианскую дату
	https://ru.wikipedia.org/wiki/%D0%AE%D0%BB%D0%B8%D0%B0%D0%BD%D1%81%D0%BA%D0%B0%D1%8F_%D0%B4%D0%B0%D1%82%D0%B0
	раздел "Вычисление номера юлианского дня (JDN) по дате григорианского календаря"
	Тестовые данные					Ожидаемый результат
	1.12.2018					2458454
	1.1.2018					2458120
	1.6.2000					2451697
	21.12.2012					2456283
	*/
	unsigned int countJND(Date date)
	{
		int a = (14 - date.month) / 12;
		int y = date.year + 4800 - a;
		int m = date.month + 12 * a - 3;
		int jdn = date.day + ((153 * m + 2) / 5) + 365 * y + (y / 4) - 32083;
		return jdn;
	}
	/*
	Рассчитывает количество дней между двумя датами.
	При реализвации используйте CountJND
	*/
	int countDistance(Date from, Date to)
	{
		int ans = countJND(to) - countJND(from);
		return ans;
	}
	/*
	Выводит в консоль дату в формате: dd.mm.yyyy (2.10.2001)
	Если параметр DateFormat равен MonthAsString, то вывести дату в формате: dd monthName yyyy (2 октября 2001)
	*/
	void printMonth(Month month)
	{
		switch (month)
		{
		case ext::January:
			cout << "January";
			break;
		case ext::February:
			cout << "February";
			break;
		case ext::March:
			cout << "March";
			break;
		case ext::April:
			cout << "April";
			break;
		case ext::May:
			cout << "May";
			break;
		case ext::June:
			cout << "June";
			break;
		case ext::July:
			cout << "July";
			break;
		case ext::August:
			cout << "August";
			break;
		case ext::September:
			cout << "September";
			break;
		case ext::October:
			cout << "October";
			break;
		case ext::Novemver:
			cout << "Novemver";
			break;
		case ext::December:
			cout << "December";
			break;
		default:
			break;
		}
	}

	void print(Date data, DateFormat format = DateFormat::MonthAsInt)
	{
		if (format == DateFormat::MonthAsString)
		{
			cout << data.day << " ";
			printMonth(data.month);
			cout << " " << data.year;
		}
		else
		{
			cout << data.day << "." << data.month << "." << data.year;
		}
		cout << endl;
	}

	/*
	Возвращает сезон (зима, весна, лето, осень) передаваемой даты
	*/
	Season getSeason(Date date)
	{
		Season ans;
		switch (date.month)
		{
		case 12:
		case 1:
		case 2: 
			ans = Winter;
			break;
		case 3:
		case 4:
		case 5:
			ans = Spring;
			break;
		case 6:
		case 7:
		case 8:
			ans = Summer;
			break;
		case 9:
		case 10:
		case 11:
			ans = Autumn;
			break;
		}
		return ans;
	}
	void printSeason(Season sn)
	{
		switch (sn)
		{
		case ext::Winter:
			cout << "Winter";
			break;
		case ext::Spring:
			cout << "Spring";
			break;
		case ext::Summer:
			cout << "Summer";
			break;
		case ext::Autumn:
			cout << "Autumn";
			break;
		}
		cout << endl;
	}

	/*
	Меняет даты местами
	*/
	void swap(Date * lhs, Date * rhs)
	{
		Date fd = *lhs;
		*lhs = *rhs;
		*rhs = fd;
	}

	/*
	Сравнивает даты на эквивалентность
	*/
	bool isSame(Date* lhs, Date * rhs)
	{
		bool asn = false;
		Date fd = *lhs;
		Date sd = *rhs;
		if (fd.day == sd.day && fd.month == sd.month)
		{
			asn = true;
		}
		return asn;
	}
	/*
	Возвращает указатель на большую дату
	*/
	Date * max(Date * lhs, Date * rsh)
	{	
		Date * ans;
		if (countJND(*lhs) > countJND(*rsh))
		{
			ans = lhs;
		}
		else
		{
			ans = rsh;
		}
		return ans;
	}

	/*
	Возвращает указатель на меньшую дату
	*/
	Date * min(Date * lhs, Date * rsh)
	{
		Date * ans;
		if (countJND(*lhs) > countJND(*rsh))
		{
			ans = rsh;
		}
		else
		{
			ans = lhs;
		}
		return ans;
	}

	/*
	Возвращает указатель на минимальную дату в переданном массиве дат
	*/
	Date * getMinDate(Date dates[], int size);

	/*
	Возвращает указатель на максимальную дату в переданном массиве дат
	*/
	Date * getMaxDate(Date dates[], int size);

	/*
	Проверяет может ли существовать дата с передаваемыми значениями.
	В случае успеха возвращает true, и заполняет дату по переданному адресу.
	Если дата с переданными параметрами существовать не может,
	возвращает false.
	*/
	bool tryFillDate(Date * date, int year, int month, int day);
}
